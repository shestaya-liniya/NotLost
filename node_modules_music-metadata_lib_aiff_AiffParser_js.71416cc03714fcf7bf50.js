"use strict";
(self["webpackChunktelegram_t"] = self["webpackChunktelegram_t"] || []).push([["node_modules_music-metadata_lib_aiff_AiffParser_js"],{

/***/ "./node_modules/music-metadata/lib/aiff/AiffParser.js":
/*!************************************************************!*\
  !*** ./node_modules/music-metadata/lib/aiff/AiffParser.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AIFFParser: () => (/* binding */ AIFFParser)
/* harmony export */ });
/* harmony import */ var token_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! token-types */ "./node_modules/token-types/lib/index.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");
/* harmony import */ var strtok3__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! strtok3 */ "./node_modules/strtok3/lib/core.js");
/* harmony import */ var _id3v2_ID3v2Parser_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../id3v2/ID3v2Parser.js */ "./node_modules/music-metadata/lib/id3v2/ID3v2Parser.js");
/* harmony import */ var _common_FourCC_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../common/FourCC.js */ "./node_modules/music-metadata/lib/common/FourCC.js");
/* harmony import */ var _common_BasicParser_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/BasicParser.js */ "./node_modules/music-metadata/lib/common/BasicParser.js");
/* harmony import */ var _AiffToken_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./AiffToken.js */ "./node_modules/music-metadata/lib/aiff/AiffToken.js");
/* harmony import */ var _iff_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../iff/index.js */ "./node_modules/music-metadata/lib/iff/index.js");









const debug = debug__WEBPACK_IMPORTED_MODULE_1__('music-metadata:parser:aiff');
/**
 * AIFF - Audio Interchange File Format
 *
 * Ref:
 * - http://www-mmsp.ece.mcgill.ca/Documents/AudioFormats/AIFF/AIFF.html
 * - http://www-mmsp.ece.mcgill.ca/Documents/AudioFormats/AIFF/Docs/AIFF-1.3.pdf
 */
class AIFFParser extends _common_BasicParser_js__WEBPACK_IMPORTED_MODULE_3__.BasicParser {
    constructor() {
        super(...arguments);
        this.isCompressed = null;
    }
    async parse() {
        const header = await this.tokenizer.readToken(_iff_index_js__WEBPACK_IMPORTED_MODULE_4__.Header);
        if (header.chunkID !== 'FORM')
            throw new _AiffToken_js__WEBPACK_IMPORTED_MODULE_5__.AiffContentError('Invalid Chunk-ID, expected \'FORM\''); // Not AIFF format
        const type = await this.tokenizer.readToken(_common_FourCC_js__WEBPACK_IMPORTED_MODULE_6__.FourCcToken);
        switch (type) {
            case 'AIFF':
                this.metadata.setFormat('container', type);
                this.isCompressed = false;
                break;
            case 'AIFC':
                this.metadata.setFormat('container', 'AIFF-C');
                this.isCompressed = true;
                break;
            default:
                throw new _AiffToken_js__WEBPACK_IMPORTED_MODULE_5__.AiffContentError(`Unsupported AIFF type: ${type}`);
        }
        this.metadata.setFormat('lossless', !this.isCompressed);
        try {
            while (!this.tokenizer.fileInfo.size || this.tokenizer.fileInfo.size - this.tokenizer.position >= _iff_index_js__WEBPACK_IMPORTED_MODULE_4__.Header.len) {
                debug(`Reading AIFF chunk at offset=${this.tokenizer.position}`);
                const chunkHeader = await this.tokenizer.readToken(_iff_index_js__WEBPACK_IMPORTED_MODULE_4__.Header);
                const nextChunk = 2 * Math.round(chunkHeader.chunkSize / 2);
                const bytesRead = await this.readData(chunkHeader);
                await this.tokenizer.ignore(nextChunk - bytesRead);
            }
        }
        catch (err) {
            if (err instanceof strtok3__WEBPACK_IMPORTED_MODULE_2__.EndOfStreamError) {
                debug("End-of-stream");
            }
            else {
                throw err;
            }
        }
    }
    async readData(header) {
        switch (header.chunkID) {
            case 'COMM': { // The Common Chunk
                if (this.isCompressed === null) {
                    throw new _AiffToken_js__WEBPACK_IMPORTED_MODULE_5__.AiffContentError('Failed to parse AIFF.COMM chunk when compression type is unknown');
                }
                const common = await this.tokenizer.readToken(new _AiffToken_js__WEBPACK_IMPORTED_MODULE_5__.Common(header, this.isCompressed));
                this.metadata.setFormat('bitsPerSample', common.sampleSize);
                this.metadata.setFormat('sampleRate', common.sampleRate);
                this.metadata.setFormat('numberOfChannels', common.numChannels);
                this.metadata.setFormat('numberOfSamples', common.numSampleFrames);
                this.metadata.setFormat('duration', common.numSampleFrames / common.sampleRate);
                if (common.compressionName || common.compressionType) {
                    this.metadata.setFormat('codec', common.compressionName ?? _AiffToken_js__WEBPACK_IMPORTED_MODULE_5__.compressionTypes[common.compressionType]);
                }
                return header.chunkSize;
            }
            case 'ID3 ': { // ID3-meta-data
                const id3_data = await this.tokenizer.readToken(new token_types__WEBPACK_IMPORTED_MODULE_0__.Uint8ArrayType(header.chunkSize));
                const rst = strtok3__WEBPACK_IMPORTED_MODULE_2__.fromBuffer(id3_data);
                await new _id3v2_ID3v2Parser_js__WEBPACK_IMPORTED_MODULE_7__.ID3v2Parser().parse(this.metadata, rst, this.options);
                return header.chunkSize;
            }
            case 'SSND': // Sound Data Chunk
                if (this.metadata.format.duration) {
                    this.metadata.setFormat('bitrate', 8 * header.chunkSize / this.metadata.format.duration);
                }
                return 0;
            case 'NAME': // Sample name chunk
            case 'AUTH': // Author chunk
            case '(c) ': // Copyright chunk
            case 'ANNO': // Annotation chunk
                return this.readTextChunk(header);
            default:
                debug(`Ignore chunk id=${header.chunkID}, size=${header.chunkSize}`);
                return 0;
        }
    }
    async readTextChunk(header) {
        const value = await this.tokenizer.readToken(new token_types__WEBPACK_IMPORTED_MODULE_0__.StringType(header.chunkSize, 'ascii'));
        const values = value.split('\0').map(v => v.trim()).filter(v => v?.length);
        await Promise.all(values.map(v => this.metadata.addTag('AIFF', header.chunkID, v)));
        return header.chunkSize;
    }
}
//# sourceMappingURL=AiffParser.js.map

/***/ }),

/***/ "./node_modules/music-metadata/lib/aiff/AiffToken.js":
/*!***********************************************************!*\
  !*** ./node_modules/music-metadata/lib/aiff/AiffToken.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AiffContentError: () => (/* binding */ AiffContentError),
/* harmony export */   Common: () => (/* binding */ Common),
/* harmony export */   compressionTypes: () => (/* binding */ compressionTypes)
/* harmony export */ });
/* harmony import */ var token_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! token-types */ "./node_modules/token-types/lib/index.js");
/* harmony import */ var _common_FourCC_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/FourCC.js */ "./node_modules/music-metadata/lib/common/FourCC.js");
/* harmony import */ var _ParseError_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ParseError.js */ "./node_modules/music-metadata/lib/ParseError.js");



const compressionTypes = {
    NONE: 'not compressed	PCM	Apple Computer',
    sowt: 'PCM (byte swapped)',
    fl32: '32-bit floating point IEEE 32-bit float',
    fl64: '64-bit floating point IEEE 64-bit float	Apple Computer',
    alaw: 'ALaw 2:1	8-bit ITU-T G.711 A-law',
    ulaw: 'µLaw 2:1	8-bit ITU-T G.711 µ-law	Apple Computer',
    ULAW: 'CCITT G.711 u-law 8-bit ITU-T G.711 µ-law',
    ALAW: 'CCITT G.711 A-law 8-bit ITU-T G.711 A-law',
    FL32: 'Float 32	IEEE 32-bit float '
};
class AiffContentError extends (0,_ParseError_js__WEBPACK_IMPORTED_MODULE_1__.makeUnexpectedFileContentError)('AIFF') {
}
class Common {
    constructor(header, isAifc) {
        this.isAifc = isAifc;
        const minimumChunkSize = isAifc ? 22 : 18;
        if (header.chunkSize < minimumChunkSize)
            throw new AiffContentError(`COMMON CHUNK size should always be at least ${minimumChunkSize}`);
        this.len = header.chunkSize;
    }
    get(buf, off) {
        // see: https://cycling74.com/forums/aiffs-80-bit-sample-rate-value
        const shift = token_types__WEBPACK_IMPORTED_MODULE_0__.UINT16_BE.get(buf, off + 8) - 16398;
        const baseSampleRate = token_types__WEBPACK_IMPORTED_MODULE_0__.UINT16_BE.get(buf, off + 8 + 2);
        const res = {
            numChannels: token_types__WEBPACK_IMPORTED_MODULE_0__.UINT16_BE.get(buf, off),
            numSampleFrames: token_types__WEBPACK_IMPORTED_MODULE_0__.UINT32_BE.get(buf, off + 2),
            sampleSize: token_types__WEBPACK_IMPORTED_MODULE_0__.UINT16_BE.get(buf, off + 6),
            sampleRate: shift < 0 ? baseSampleRate >> Math.abs(shift) : baseSampleRate << shift
        };
        if (this.isAifc) {
            res.compressionType = _common_FourCC_js__WEBPACK_IMPORTED_MODULE_2__.FourCcToken.get(buf, off + 18);
            if (this.len > 22) {
                const strLen = token_types__WEBPACK_IMPORTED_MODULE_0__.UINT8.get(buf, off + 22);
                if (strLen > 0) {
                    const padding = (strLen + 1) % 2;
                    if (23 + strLen + padding === this.len) {
                        res.compressionName = new token_types__WEBPACK_IMPORTED_MODULE_0__.StringType(strLen, 'latin1').get(buf, off + 23);
                    }
                    else {
                        throw new AiffContentError('Illegal pstring length');
                    }
                }
                else {
                    res.compressionName = undefined;
                }
            }
        }
        else {
            res.compressionName = 'PCM';
        }
        return res;
    }
}
//# sourceMappingURL=AiffToken.js.map

/***/ }),

/***/ "./node_modules/music-metadata/lib/iff/index.js":
/*!******************************************************!*\
  !*** ./node_modules/music-metadata/lib/iff/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Header: () => (/* binding */ Header)
/* harmony export */ });
/* harmony import */ var token_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! token-types */ "./node_modules/token-types/lib/index.js");
/* harmony import */ var _common_FourCC_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/FourCC.js */ "./node_modules/music-metadata/lib/common/FourCC.js");


/**
 * Common AIFF chunk header
 */
const Header = {
    len: 8,
    get: (buf, off) => {
        return {
            // Chunk type ID
            chunkID: _common_FourCC_js__WEBPACK_IMPORTED_MODULE_1__.FourCcToken.get(buf, off),
            // Chunk size
            chunkSize: Number(BigInt(token_types__WEBPACK_IMPORTED_MODULE_0__.UINT32_BE.get(buf, off + 4)))
        };
    }
};
//# sourceMappingURL=index.js.map

/***/ })

}]);
//# sourceMappingURL=node_modules_music-metadata_lib_aiff_AiffParser_js.71416cc03714fcf7bf50.js.map