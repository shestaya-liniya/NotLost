"use strict";
(self["webpackChunktelegram_t"] = self["webpackChunktelegram_t"] || []).push([["vendors-node_modules_music-metadata_lib_wav_WaveParser_js"],{

/***/ "./node_modules/music-metadata/lib/riff/RiffChunk.js":
/*!***********************************************************!*\
  !*** ./node_modules/music-metadata/lib/riff/RiffChunk.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Header: () => (/* binding */ Header),
/* harmony export */   ListInfoTagValue: () => (/* binding */ ListInfoTagValue)
/* harmony export */ });
/* harmony import */ var token_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! token-types */ "./node_modules/token-types/lib/index.js");

/**
 * Common RIFF chunk header
 */
const Header = {
    len: 8,
    get: (buf, off) => {
        return {
            // Group-ID
            chunkID: new token_types__WEBPACK_IMPORTED_MODULE_0__.StringType(4, 'latin1').get(buf, off),
            // Size
            chunkSize: token_types__WEBPACK_IMPORTED_MODULE_0__.UINT32_LE.get(buf, off + 4)
        };
    }
};
/**
 * Token to parse RIFF-INFO tag value
 */
class ListInfoTagValue {
    constructor(tagHeader) {
        this.tagHeader = tagHeader;
        this.len = tagHeader.chunkSize;
        this.len += this.len & 1; // if it is an odd length, round up to even
    }
    get(buf, off) {
        return new token_types__WEBPACK_IMPORTED_MODULE_0__.StringType(this.tagHeader.chunkSize, 'ascii').get(buf, off);
    }
}
//# sourceMappingURL=RiffChunk.js.map

/***/ }),

/***/ "./node_modules/music-metadata/lib/wav/BwfChunk.js":
/*!*********************************************************!*\
  !*** ./node_modules/music-metadata/lib/wav/BwfChunk.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BroadcastAudioExtensionChunk: () => (/* binding */ BroadcastAudioExtensionChunk)
/* harmony export */ });
/* harmony import */ var token_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! token-types */ "./node_modules/token-types/lib/index.js");
/* harmony import */ var _common_Util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/Util.js */ "./node_modules/music-metadata/lib/common/Util.js");


/**
 * Broadcast Audio Extension Chunk
 * Ref: https://tech.ebu.ch/docs/tech/tech3285.pdf
 */
const BroadcastAudioExtensionChunk = {
    len: 420,
    get: (uint8array, off) => {
        return {
            description: (0,_common_Util_js__WEBPACK_IMPORTED_MODULE_1__.stripNulls)(new token_types__WEBPACK_IMPORTED_MODULE_0__.StringType(256, 'ascii').get(uint8array, off)).trim(),
            originator: (0,_common_Util_js__WEBPACK_IMPORTED_MODULE_1__.stripNulls)(new token_types__WEBPACK_IMPORTED_MODULE_0__.StringType(32, 'ascii').get(uint8array, off + 256)).trim(),
            originatorReference: (0,_common_Util_js__WEBPACK_IMPORTED_MODULE_1__.stripNulls)(new token_types__WEBPACK_IMPORTED_MODULE_0__.StringType(32, 'ascii').get(uint8array, off + 288)).trim(),
            originationDate: (0,_common_Util_js__WEBPACK_IMPORTED_MODULE_1__.stripNulls)(new token_types__WEBPACK_IMPORTED_MODULE_0__.StringType(10, 'ascii').get(uint8array, off + 320)).trim(),
            originationTime: (0,_common_Util_js__WEBPACK_IMPORTED_MODULE_1__.stripNulls)(new token_types__WEBPACK_IMPORTED_MODULE_0__.StringType(8, 'ascii').get(uint8array, off + 330)).trim(),
            timeReferenceLow: token_types__WEBPACK_IMPORTED_MODULE_0__.UINT32_LE.get(uint8array, off + 338),
            timeReferenceHigh: token_types__WEBPACK_IMPORTED_MODULE_0__.UINT32_LE.get(uint8array, off + 342),
            version: token_types__WEBPACK_IMPORTED_MODULE_0__.UINT16_LE.get(uint8array, off + 346),
            umid: new token_types__WEBPACK_IMPORTED_MODULE_0__.Uint8ArrayType(64).get(uint8array, off + 348),
            loudnessValue: token_types__WEBPACK_IMPORTED_MODULE_0__.UINT16_LE.get(uint8array, off + 412),
            maxTruePeakLevel: token_types__WEBPACK_IMPORTED_MODULE_0__.UINT16_LE.get(uint8array, off + 414),
            maxMomentaryLoudness: token_types__WEBPACK_IMPORTED_MODULE_0__.UINT16_LE.get(uint8array, off + 416),
            maxShortTermLoudness: token_types__WEBPACK_IMPORTED_MODULE_0__.UINT16_LE.get(uint8array, off + 418)
        };
    }
};
//# sourceMappingURL=BwfChunk.js.map

/***/ }),

/***/ "./node_modules/music-metadata/lib/wav/WaveChunk.js":
/*!**********************************************************!*\
  !*** ./node_modules/music-metadata/lib/wav/WaveChunk.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FactChunk: () => (/* binding */ FactChunk),
/* harmony export */   Format: () => (/* binding */ Format),
/* harmony export */   WaveContentError: () => (/* binding */ WaveContentError),
/* harmony export */   WaveFormat: () => (/* binding */ WaveFormat),
/* harmony export */   WaveFormatNameMap: () => (/* binding */ WaveFormatNameMap)
/* harmony export */ });
/* harmony import */ var token_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! token-types */ "./node_modules/token-types/lib/index.js");
/* harmony import */ var _ParseError_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ParseError.js */ "./node_modules/music-metadata/lib/ParseError.js");


class WaveContentError extends (0,_ParseError_js__WEBPACK_IMPORTED_MODULE_1__.makeUnexpectedFileContentError)('Wave') {
}
/**
 * Ref: https://msdn.microsoft.com/en-us/library/windows/desktop/dd317599(v=vs.85).aspx
 */
const WaveFormat = {
    PCM: 0x0001,
    // MPEG-4 and AAC Audio Types
    ADPCM: 0x0002,
    IEEE_FLOAT: 0x0003,
    MPEG_ADTS_AAC: 0x1600,
    MPEG_LOAS: 0x1602,
    RAW_AAC1: 0x00FF,
    // Dolby Audio Types
    DOLBY_AC3_SPDIF: 0x0092,
    DVM: 0x2000,
    RAW_SPORT: 0x0240,
    ESST_AC3: 0x0241,
    DRM: 0x0009,
    DTS2: 0x2001,
    MPEG: 0x0050
};
const WaveFormatNameMap = {
    [WaveFormat.PCM]: 'PCM',
    [WaveFormat.ADPCM]: 'ADPCM',
    [WaveFormat.IEEE_FLOAT]: 'IEEE_FLOAT',
    [WaveFormat.MPEG_ADTS_AAC]: 'MPEG_ADTS_AAC',
    [WaveFormat.MPEG_LOAS]: 'MPEG_LOAS',
    [WaveFormat.RAW_AAC1]: 'RAW_AAC1',
    [WaveFormat.DOLBY_AC3_SPDIF]: 'DOLBY_AC3_SPDIF',
    [WaveFormat.DVM]: 'DVM',
    [WaveFormat.RAW_SPORT]: 'RAW_SPORT',
    [WaveFormat.ESST_AC3]: 'ESST_AC3',
    [WaveFormat.DRM]: 'DRM',
    [WaveFormat.DTS2]: 'DTS2',
    [WaveFormat.MPEG]: 'MPEG'
};
/**
 * format chunk; chunk-id is "fmt "
 * http://soundfile.sapp.org/doc/WaveFormat/
 */
class Format {
    constructor(header) {
        if (header.chunkSize < 16)
            throw new WaveContentError('Invalid chunk size');
        this.len = header.chunkSize;
    }
    get(buf, off) {
        return {
            wFormatTag: token_types__WEBPACK_IMPORTED_MODULE_0__.UINT16_LE.get(buf, off),
            nChannels: token_types__WEBPACK_IMPORTED_MODULE_0__.UINT16_LE.get(buf, off + 2),
            nSamplesPerSec: token_types__WEBPACK_IMPORTED_MODULE_0__.UINT32_LE.get(buf, off + 4),
            nAvgBytesPerSec: token_types__WEBPACK_IMPORTED_MODULE_0__.UINT32_LE.get(buf, off + 8),
            nBlockAlign: token_types__WEBPACK_IMPORTED_MODULE_0__.UINT16_LE.get(buf, off + 12),
            wBitsPerSample: token_types__WEBPACK_IMPORTED_MODULE_0__.UINT16_LE.get(buf, off + 14)
        };
    }
}
/**
 * Fact chunk; chunk-id is "fact"
 * http://www-mmsp.ece.mcgill.ca/Documents/AudioFormats/WAVE/WAVE.html
 * http://www.recordingblogs.com/wiki/fact-chunk-of-a-wave-file
 */
class FactChunk {
    constructor(header) {
        if (header.chunkSize < 4) {
            throw new WaveContentError('Invalid fact chunk size.');
        }
        this.len = header.chunkSize;
    }
    get(buf, off) {
        return {
            dwSampleLength: token_types__WEBPACK_IMPORTED_MODULE_0__.UINT32_LE.get(buf, off)
        };
    }
}
//# sourceMappingURL=WaveChunk.js.map

/***/ }),

/***/ "./node_modules/music-metadata/lib/wav/WaveParser.js":
/*!***********************************************************!*\
  !*** ./node_modules/music-metadata/lib/wav/WaveParser.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WaveParser: () => (/* binding */ WaveParser)
/* harmony export */ });
/* harmony import */ var strtok3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! strtok3 */ "./node_modules/strtok3/lib/core.js");
/* harmony import */ var token_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! token-types */ "./node_modules/token-types/lib/index.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");
/* harmony import */ var _riff_RiffChunk_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../riff/RiffChunk.js */ "./node_modules/music-metadata/lib/riff/RiffChunk.js");
/* harmony import */ var _WaveChunk_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./WaveChunk.js */ "./node_modules/music-metadata/lib/wav/WaveChunk.js");
/* harmony import */ var _id3v2_ID3v2Parser_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../id3v2/ID3v2Parser.js */ "./node_modules/music-metadata/lib/id3v2/ID3v2Parser.js");
/* harmony import */ var _common_Util_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../common/Util.js */ "./node_modules/music-metadata/lib/common/Util.js");
/* harmony import */ var _common_FourCC_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../common/FourCC.js */ "./node_modules/music-metadata/lib/common/FourCC.js");
/* harmony import */ var _common_BasicParser_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/BasicParser.js */ "./node_modules/music-metadata/lib/common/BasicParser.js");
/* harmony import */ var _BwfChunk_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./BwfChunk.js */ "./node_modules/music-metadata/lib/wav/BwfChunk.js");











const debug = debug__WEBPACK_IMPORTED_MODULE_2__('music-metadata:parser:RIFF');
/**
 * Resource Interchange File Format (RIFF) Parser
 *
 * WAVE PCM soundfile format
 *
 * Ref:
 * - http://www.johnloomis.org/cpe102/asgn/asgn1/riff.html
 * - http://soundfile.sapp.org/doc/WaveFormat
 *
 * ToDo: Split WAVE part from RIFF parser
 */
class WaveParser extends _common_BasicParser_js__WEBPACK_IMPORTED_MODULE_3__.BasicParser {
    constructor() {
        super(...arguments);
        this.blockAlign = 0;
    }
    async parse() {
        const riffHeader = await this.tokenizer.readToken(_riff_RiffChunk_js__WEBPACK_IMPORTED_MODULE_4__.Header);
        debug(`pos=${this.tokenizer.position}, parse: chunkID=${riffHeader.chunkID}`);
        if (riffHeader.chunkID !== 'RIFF')
            return; // Not RIFF format
        return this.parseRiffChunk(riffHeader.chunkSize).catch(err => {
            if (!(err instanceof strtok3__WEBPACK_IMPORTED_MODULE_0__.EndOfStreamError)) {
                throw err;
            }
        });
    }
    async parseRiffChunk(chunkSize) {
        const type = await this.tokenizer.readToken(_common_FourCC_js__WEBPACK_IMPORTED_MODULE_5__.FourCcToken);
        this.metadata.setFormat('container', type);
        switch (type) {
            case 'WAVE':
                return this.readWaveChunk(chunkSize - _common_FourCC_js__WEBPACK_IMPORTED_MODULE_5__.FourCcToken.len);
            default:
                throw new _WaveChunk_js__WEBPACK_IMPORTED_MODULE_6__.WaveContentError(`Unsupported RIFF format: RIFF/${type}`);
        }
    }
    async readWaveChunk(remaining) {
        while (remaining >= _riff_RiffChunk_js__WEBPACK_IMPORTED_MODULE_4__.Header.len) {
            const header = await this.tokenizer.readToken(_riff_RiffChunk_js__WEBPACK_IMPORTED_MODULE_4__.Header);
            remaining -= _riff_RiffChunk_js__WEBPACK_IMPORTED_MODULE_4__.Header.len + header.chunkSize;
            if (header.chunkSize > remaining) {
                this.metadata.addWarning('Data chunk size exceeds file size');
            }
            this.header = header;
            debug(`pos=${this.tokenizer.position}, readChunk: chunkID=RIFF/WAVE/${header.chunkID}`);
            switch (header.chunkID) {
                case 'LIST':
                    await this.parseListTag(header);
                    break;
                case 'fact': // extended Format chunk,
                    this.metadata.setFormat('lossless', false);
                    this.fact = await this.tokenizer.readToken(new _WaveChunk_js__WEBPACK_IMPORTED_MODULE_6__.FactChunk(header));
                    break;
                case 'fmt ': { // The Util Chunk, non-PCM Formats
                    const fmt = await this.tokenizer.readToken(new _WaveChunk_js__WEBPACK_IMPORTED_MODULE_6__.Format(header));
                    let subFormat = _WaveChunk_js__WEBPACK_IMPORTED_MODULE_6__.WaveFormatNameMap[fmt.wFormatTag];
                    if (!subFormat) {
                        debug(`WAVE/non-PCM format=${fmt.wFormatTag}`);
                        subFormat = `non-PCM (${fmt.wFormatTag})`;
                    }
                    this.metadata.setFormat('codec', subFormat);
                    this.metadata.setFormat('bitsPerSample', fmt.wBitsPerSample);
                    this.metadata.setFormat('sampleRate', fmt.nSamplesPerSec);
                    this.metadata.setFormat('numberOfChannels', fmt.nChannels);
                    this.metadata.setFormat('bitrate', fmt.nBlockAlign * fmt.nSamplesPerSec * 8);
                    this.blockAlign = fmt.nBlockAlign;
                    break;
                }
                case 'id3 ': // The way Picard, FooBar currently stores, ID3 meta-data
                case 'ID3 ': { // The way Mp3Tags stores ID3 meta-data
                    const id3_data = await this.tokenizer.readToken(new token_types__WEBPACK_IMPORTED_MODULE_1__.Uint8ArrayType(header.chunkSize));
                    const rst = strtok3__WEBPACK_IMPORTED_MODULE_0__.fromBuffer(id3_data);
                    await new _id3v2_ID3v2Parser_js__WEBPACK_IMPORTED_MODULE_7__.ID3v2Parser().parse(this.metadata, rst, this.options);
                    break;
                }
                case 'data': { // PCM-data
                    if (this.metadata.format.lossless !== false) {
                        this.metadata.setFormat('lossless', true);
                    }
                    let chunkSize = header.chunkSize;
                    if (this.tokenizer.fileInfo.size) {
                        const calcRemaining = this.tokenizer.fileInfo.size - this.tokenizer.position;
                        if (calcRemaining < chunkSize) {
                            this.metadata.addWarning('data chunk length exceeding file length');
                            chunkSize = calcRemaining;
                        }
                    }
                    const numberOfSamples = this.fact ? this.fact.dwSampleLength : (chunkSize === 0xffffffff ? undefined : chunkSize / this.blockAlign);
                    if (numberOfSamples) {
                        this.metadata.setFormat('numberOfSamples', numberOfSamples);
                        if (this.metadata.format.sampleRate) {
                            this.metadata.setFormat('duration', numberOfSamples / this.metadata.format.sampleRate);
                        }
                    }
                    if (this.metadata.format.codec === 'ADPCM') { // ADPCM is 4 bits lossy encoding resulting in 352kbps
                        this.metadata.setFormat('bitrate', 352000);
                    }
                    else if (this.metadata.format.sampleRate) {
                        this.metadata.setFormat('bitrate', this.blockAlign * this.metadata.format.sampleRate * 8);
                    }
                    await this.tokenizer.ignore(header.chunkSize);
                    break;
                }
                case 'bext': { // Broadcast Audio Extension chunk	https://tech.ebu.ch/docs/tech/tech3285.pdf
                    const bext = await this.tokenizer.readToken(_BwfChunk_js__WEBPACK_IMPORTED_MODULE_8__.BroadcastAudioExtensionChunk);
                    Object.keys(bext).forEach(key => {
                        this.metadata.addTag('exif', `bext.${key}`, bext[key]);
                    });
                    const bextRemaining = header.chunkSize - _BwfChunk_js__WEBPACK_IMPORTED_MODULE_8__.BroadcastAudioExtensionChunk.len;
                    await this.tokenizer.ignore(bextRemaining);
                    break;
                }
                case '\x00\x00\x00\x00': // padding ??
                    debug(`Ignore padding chunk: RIFF/${header.chunkID} of ${header.chunkSize} bytes`);
                    this.metadata.addWarning(`Ignore chunk: RIFF/${header.chunkID}`);
                    await this.tokenizer.ignore(header.chunkSize);
                    break;
                default:
                    debug(`Ignore chunk: RIFF/${header.chunkID} of ${header.chunkSize} bytes`);
                    this.metadata.addWarning(`Ignore chunk: RIFF/${header.chunkID}`);
                    await this.tokenizer.ignore(header.chunkSize);
            }
            if (this.header.chunkSize % 2 === 1) {
                debug('Read odd padding byte'); // https://wiki.multimedia.cx/index.php/RIFF
                await this.tokenizer.ignore(1);
            }
        }
    }
    async parseListTag(listHeader) {
        const listType = await this.tokenizer.readToken(new token_types__WEBPACK_IMPORTED_MODULE_1__.StringType(4, 'latin1'));
        debug('pos=%s, parseListTag: chunkID=RIFF/WAVE/LIST/%s', this.tokenizer.position, listType);
        switch (listType) {
            case 'INFO':
                return this.parseRiffInfoTags(listHeader.chunkSize - 4);
            default:
                this.metadata.addWarning(`Ignore chunk: RIFF/WAVE/LIST/${listType}`);
                debug(`Ignoring chunkID=RIFF/WAVE/LIST/${listType}`);
                return this.tokenizer.ignore(listHeader.chunkSize - 4).then();
        }
    }
    async parseRiffInfoTags(chunkSize) {
        while (chunkSize >= 8) {
            const header = await this.tokenizer.readToken(_riff_RiffChunk_js__WEBPACK_IMPORTED_MODULE_4__.Header);
            const valueToken = new _riff_RiffChunk_js__WEBPACK_IMPORTED_MODULE_4__.ListInfoTagValue(header);
            const value = await this.tokenizer.readToken(valueToken);
            this.addTag(header.chunkID, _common_Util_js__WEBPACK_IMPORTED_MODULE_9__.stripNulls(value));
            chunkSize -= (8 + valueToken.len);
        }
        if (chunkSize !== 0) {
            throw new _WaveChunk_js__WEBPACK_IMPORTED_MODULE_6__.WaveContentError(`Illegal remaining size: ${chunkSize}`);
        }
    }
    addTag(id, value) {
        this.metadata.addTag('exif', id, value);
    }
}
//# sourceMappingURL=WaveParser.js.map

/***/ })

}]);
//# sourceMappingURL=vendors-node_modules_music-metadata_lib_wav_WaveParser_js.e6a01818b725b606b68a.js.map