"use strict";
(self["webpackChunktelegram_t"] = self["webpackChunktelegram_t"] || []).push([["node_modules_music-metadata_lib_dsf_DsfParser_js"],{

/***/ "./node_modules/music-metadata/lib/dsf/DsfChunk.js":
/*!*********************************************************!*\
  !*** ./node_modules/music-metadata/lib/dsf/DsfChunk.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ChannelType: () => (/* binding */ ChannelType),
/* harmony export */   ChunkHeader: () => (/* binding */ ChunkHeader),
/* harmony export */   DsdChunk: () => (/* binding */ DsdChunk),
/* harmony export */   FormatChunk: () => (/* binding */ FormatChunk)
/* harmony export */ });
/* harmony import */ var token_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! token-types */ "./node_modules/token-types/lib/index.js");
/* harmony import */ var _common_FourCC_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/FourCC.js */ "./node_modules/music-metadata/lib/common/FourCC.js");


/**
 * Common chunk DSD header: the 'chunk name (Four-CC)' & chunk size
 */
const ChunkHeader = {
    len: 12,
    get: (buf, off) => {
        return { id: _common_FourCC_js__WEBPACK_IMPORTED_MODULE_1__.FourCcToken.get(buf, off), size: token_types__WEBPACK_IMPORTED_MODULE_0__.UINT64_LE.get(buf, off + 4) };
    }
};
/**
 * Common chunk DSD header: the 'chunk name (Four-CC)' & chunk size
 */
const DsdChunk = {
    len: 16,
    get: (buf, off) => {
        return {
            fileSize: token_types__WEBPACK_IMPORTED_MODULE_0__.INT64_LE.get(buf, off),
            metadataPointer: token_types__WEBPACK_IMPORTED_MODULE_0__.INT64_LE.get(buf, off + 8)
        };
    }
};
const ChannelType = {
    mono: 1,
    stereo: 2,
    channels: 3,
    quad: 4,
    '4 channels': 5,
    '5 channels': 6,
    '5.1 channels': 7
};
/**
 * Common chunk DSD header: the 'chunk name (Four-CC)' & chunk size
 */
const FormatChunk = {
    len: 40,
    get: (buf, off) => {
        return {
            formatVersion: token_types__WEBPACK_IMPORTED_MODULE_0__.INT32_LE.get(buf, off),
            formatID: token_types__WEBPACK_IMPORTED_MODULE_0__.INT32_LE.get(buf, off + 4),
            channelType: token_types__WEBPACK_IMPORTED_MODULE_0__.INT32_LE.get(buf, off + 8),
            channelNum: token_types__WEBPACK_IMPORTED_MODULE_0__.INT32_LE.get(buf, off + 12),
            samplingFrequency: token_types__WEBPACK_IMPORTED_MODULE_0__.INT32_LE.get(buf, off + 16),
            bitsPerSample: token_types__WEBPACK_IMPORTED_MODULE_0__.INT32_LE.get(buf, off + 20),
            sampleCount: token_types__WEBPACK_IMPORTED_MODULE_0__.INT64_LE.get(buf, off + 24),
            blockSizePerChannel: token_types__WEBPACK_IMPORTED_MODULE_0__.INT32_LE.get(buf, off + 32)
        };
    }
};
//# sourceMappingURL=DsfChunk.js.map

/***/ }),

/***/ "./node_modules/music-metadata/lib/dsf/DsfParser.js":
/*!**********************************************************!*\
  !*** ./node_modules/music-metadata/lib/dsf/DsfParser.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DsdContentParseError: () => (/* binding */ DsdContentParseError),
/* harmony export */   DsfParser: () => (/* binding */ DsfParser)
/* harmony export */ });
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");
/* harmony import */ var _id3v2_AbstractID3Parser_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../id3v2/AbstractID3Parser.js */ "./node_modules/music-metadata/lib/id3v2/AbstractID3Parser.js");
/* harmony import */ var _DsfChunk_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./DsfChunk.js */ "./node_modules/music-metadata/lib/dsf/DsfChunk.js");
/* harmony import */ var _id3v2_ID3v2Parser_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../id3v2/ID3v2Parser.js */ "./node_modules/music-metadata/lib/id3v2/ID3v2Parser.js");
/* harmony import */ var _ParseError_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ParseError.js */ "./node_modules/music-metadata/lib/ParseError.js");





const debug = debug__WEBPACK_IMPORTED_MODULE_0__('music-metadata:parser:DSF');
class DsdContentParseError extends (0,_ParseError_js__WEBPACK_IMPORTED_MODULE_1__.makeUnexpectedFileContentError)('DSD') {
}
/**
 * DSF (dsd stream file) File Parser
 * Ref: https://dsd-guide.com/sites/default/files/white-papers/DSFFileFormatSpec_E.pdf
 */
class DsfParser extends _id3v2_AbstractID3Parser_js__WEBPACK_IMPORTED_MODULE_2__.AbstractID3Parser {
    async postId3v2Parse() {
        const p0 = this.tokenizer.position; // mark start position, normally 0
        const chunkHeader = await this.tokenizer.readToken(_DsfChunk_js__WEBPACK_IMPORTED_MODULE_3__.ChunkHeader);
        if (chunkHeader.id !== 'DSD ')
            throw new DsdContentParseError('Invalid chunk signature');
        this.metadata.setFormat('container', 'DSF');
        this.metadata.setFormat('lossless', true);
        const dsdChunk = await this.tokenizer.readToken(_DsfChunk_js__WEBPACK_IMPORTED_MODULE_3__.DsdChunk);
        if (dsdChunk.metadataPointer === BigInt(0)) {
            debug("No ID3v2 tag present");
        }
        else {
            debug(`expect ID3v2 at offset=${dsdChunk.metadataPointer}`);
            await this.parseChunks(dsdChunk.fileSize - chunkHeader.size);
            // Jump to ID3 header
            await this.tokenizer.ignore(Number(dsdChunk.metadataPointer) - this.tokenizer.position - p0);
            return new _id3v2_ID3v2Parser_js__WEBPACK_IMPORTED_MODULE_4__.ID3v2Parser().parse(this.metadata, this.tokenizer, this.options);
        }
    }
    async parseChunks(bytesRemaining) {
        while (bytesRemaining >= _DsfChunk_js__WEBPACK_IMPORTED_MODULE_3__.ChunkHeader.len) {
            const chunkHeader = await this.tokenizer.readToken(_DsfChunk_js__WEBPACK_IMPORTED_MODULE_3__.ChunkHeader);
            debug(`Parsing chunk name=${chunkHeader.id} size=${chunkHeader.size}`);
            switch (chunkHeader.id) {
                case 'fmt ': {
                    const formatChunk = await this.tokenizer.readToken(_DsfChunk_js__WEBPACK_IMPORTED_MODULE_3__.FormatChunk);
                    this.metadata.setFormat('numberOfChannels', formatChunk.channelNum);
                    this.metadata.setFormat('sampleRate', formatChunk.samplingFrequency);
                    this.metadata.setFormat('bitsPerSample', formatChunk.bitsPerSample);
                    this.metadata.setFormat('numberOfSamples', formatChunk.sampleCount);
                    this.metadata.setFormat('duration', Number(formatChunk.sampleCount) / formatChunk.samplingFrequency);
                    const bitrate = formatChunk.bitsPerSample * formatChunk.samplingFrequency * formatChunk.channelNum;
                    this.metadata.setFormat('bitrate', bitrate);
                    return; // We got what we want, stop further processing of chunks
                }
                default:
                    this.tokenizer.ignore(Number(chunkHeader.size) - _DsfChunk_js__WEBPACK_IMPORTED_MODULE_3__.ChunkHeader.len);
                    break;
            }
            bytesRemaining -= chunkHeader.size;
        }
    }
}
//# sourceMappingURL=DsfParser.js.map

/***/ }),

/***/ "./node_modules/music-metadata/lib/id3v2/AbstractID3Parser.js":
/*!********************************************************************!*\
  !*** ./node_modules/music-metadata/lib/id3v2/AbstractID3Parser.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AbstractID3Parser: () => (/* binding */ AbstractID3Parser)
/* harmony export */ });
/* harmony import */ var strtok3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! strtok3 */ "./node_modules/strtok3/lib/core.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");
/* harmony import */ var _ID3v2Token_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ID3v2Token.js */ "./node_modules/music-metadata/lib/id3v2/ID3v2Token.js");
/* harmony import */ var _ID3v2Parser_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ID3v2Parser.js */ "./node_modules/music-metadata/lib/id3v2/ID3v2Parser.js");
/* harmony import */ var _id3v1_ID3v1Parser_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../id3v1/ID3v1Parser.js */ "./node_modules/music-metadata/lib/id3v1/ID3v1Parser.js");
/* harmony import */ var _common_BasicParser_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/BasicParser.js */ "./node_modules/music-metadata/lib/common/BasicParser.js");






const debug = debug__WEBPACK_IMPORTED_MODULE_1__('music-metadata:parser:ID3');
/**
 * Abstract parser which tries take ID3v2 and ID3v1 headers.
 */
class AbstractID3Parser extends _common_BasicParser_js__WEBPACK_IMPORTED_MODULE_2__.BasicParser {
    constructor() {
        super(...arguments);
        this.id3parser = new _ID3v2Parser_js__WEBPACK_IMPORTED_MODULE_3__.ID3v2Parser();
    }
    static async startsWithID3v2Header(tokenizer) {
        return (await tokenizer.peekToken(_ID3v2Token_js__WEBPACK_IMPORTED_MODULE_4__.ID3v2Header)).fileIdentifier === 'ID3';
    }
    async parse() {
        try {
            await this.parseID3v2();
        }
        catch (err) {
            if (err instanceof strtok3__WEBPACK_IMPORTED_MODULE_0__.EndOfStreamError) {
                debug("End-of-stream");
            }
            else {
                throw err;
            }
        }
    }
    finalize() {
        return;
    }
    async parseID3v2() {
        await this.tryReadId3v2Headers();
        debug('End of ID3v2 header, go to MPEG-parser: pos=%s', this.tokenizer.position);
        await this.postId3v2Parse();
        if (this.options.skipPostHeaders && this.metadata.hasAny()) {
            this.finalize();
        }
        else {
            const id3v1parser = new _id3v1_ID3v1Parser_js__WEBPACK_IMPORTED_MODULE_5__.ID3v1Parser(this.metadata, this.tokenizer, this.options);
            await id3v1parser.parse();
            this.finalize();
        }
    }
    async tryReadId3v2Headers() {
        const id3Header = await this.tokenizer.peekToken(_ID3v2Token_js__WEBPACK_IMPORTED_MODULE_4__.ID3v2Header);
        if (id3Header.fileIdentifier === 'ID3') {
            debug('Found ID3v2 header, pos=%s', this.tokenizer.position);
            await this.id3parser.parse(this.metadata, this.tokenizer, this.options);
            return this.tryReadId3v2Headers();
        }
    }
}
//# sourceMappingURL=AbstractID3Parser.js.map

/***/ })

}]);
//# sourceMappingURL=node_modules_music-metadata_lib_dsf_DsfParser_js.32c96e8a316e07ceaf92.js.map