"use strict";
(self["webpackChunktelegram_t"] = self["webpackChunktelegram_t"] || []).push([["vendors-node_modules_music-metadata_lib_mp4_MP4Parser_js"],{

/***/ "./node_modules/music-metadata/lib/mp4/Atom.js":
/*!*****************************************************!*\
  !*** ./node_modules/music-metadata/lib/mp4/Atom.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Atom: () => (/* binding */ Atom)
/* harmony export */ });
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");
/* harmony import */ var _AtomToken_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AtomToken.js */ "./node_modules/music-metadata/lib/mp4/AtomToken.js");



const debug = debug__WEBPACK_IMPORTED_MODULE_0__('music-metadata:parser:MP4:Atom');
class Atom {
    static async readAtom(tokenizer, dataHandler, parent, remaining) {
        // Parse atom header
        const offset = tokenizer.position;
        debug(`Reading next token on offset=${offset}...`); //  buf.toString('ascii')
        const header = await tokenizer.readToken(_AtomToken_js__WEBPACK_IMPORTED_MODULE_1__.Header);
        const extended = header.length === 1n;
        if (extended) {
            header.length = await tokenizer.readToken(_AtomToken_js__WEBPACK_IMPORTED_MODULE_1__.ExtendedSize);
        }
        const atomBean = new Atom(header, extended, parent);
        const payloadLength = atomBean.getPayloadLength(remaining);
        debug(`parse atom name=${atomBean.atomPath}, extended=${atomBean.extended}, offset=${offset}, len=${atomBean.header.length}`); //  buf.toString('ascii')
        await atomBean.readData(tokenizer, dataHandler, payloadLength);
        return atomBean;
    }
    constructor(header, extended, parent) {
        this.header = header;
        this.extended = extended;
        this.parent = parent;
        this.children = [];
        this.atomPath = (this.parent ? `${this.parent.atomPath}.` : '') + this.header.name;
    }
    getHeaderLength() {
        return this.extended ? 16 : 8;
    }
    getPayloadLength(remaining) {
        return (this.header.length === 0n ? remaining : Number(this.header.length)) - this.getHeaderLength();
    }
    async readAtoms(tokenizer, dataHandler, size) {
        while (size > 0) {
            const atomBean = await Atom.readAtom(tokenizer, dataHandler, this, size);
            this.children.push(atomBean);
            size -= atomBean.header.length === 0n ? size : Number(atomBean.header.length);
        }
    }
    async readData(tokenizer, dataHandler, remaining) {
        switch (this.header.name) {
            // "Container" atoms, contains nested atoms
            case 'moov': // The Movie Atom: contains other atoms
            case 'udta': // User defined atom
            case 'trak':
            case 'mdia': // Media atom
            case 'minf': // Media Information Atom
            case 'stbl': // The Sample Table Atom
            case '<id>':
            case 'ilst':
            case 'tref':
                return this.readAtoms(tokenizer, dataHandler, this.getPayloadLength(remaining));
            case 'meta': { // Metadata Atom, ref: https://developer.apple.com/library/content/documentation/QuickTime/QTFF/Metadata/Metadata.html#//apple_ref/doc/uid/TP40000939-CH1-SW8
                // meta has 4 bytes of padding, ignore
                const peekHeader = await tokenizer.peekToken(_AtomToken_js__WEBPACK_IMPORTED_MODULE_1__.Header);
                const paddingLength = peekHeader.name === 'hdlr' ? 0 : 4;
                await tokenizer.ignore(paddingLength);
                return this.readAtoms(tokenizer, dataHandler, this.getPayloadLength(remaining) - paddingLength);
            }
            default:
                return dataHandler(this, remaining);
        }
    }
}
//# sourceMappingURL=Atom.js.map

/***/ }),

/***/ "./node_modules/music-metadata/lib/mp4/AtomToken.js":
/*!**********************************************************!*\
  !*** ./node_modules/music-metadata/lib/mp4/AtomToken.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ChapterText: () => (/* binding */ ChapterText),
/* harmony export */   DataAtom: () => (/* binding */ DataAtom),
/* harmony export */   ExtendedSize: () => (/* binding */ ExtendedSize),
/* harmony export */   FixedLengthAtom: () => (/* binding */ FixedLengthAtom),
/* harmony export */   Header: () => (/* binding */ Header),
/* harmony export */   MdhdAtom: () => (/* binding */ MdhdAtom),
/* harmony export */   Mp4ContentError: () => (/* binding */ Mp4ContentError),
/* harmony export */   MvhdAtom: () => (/* binding */ MvhdAtom),
/* harmony export */   NameAtom: () => (/* binding */ NameAtom),
/* harmony export */   SampleToChunkToken: () => (/* binding */ SampleToChunkToken),
/* harmony export */   SoundSampleDescriptionV0: () => (/* binding */ SoundSampleDescriptionV0),
/* harmony export */   SoundSampleDescriptionVersion: () => (/* binding */ SoundSampleDescriptionVersion),
/* harmony export */   StcoAtom: () => (/* binding */ StcoAtom),
/* harmony export */   StscAtom: () => (/* binding */ StscAtom),
/* harmony export */   StsdAtom: () => (/* binding */ StsdAtom),
/* harmony export */   StszAtom: () => (/* binding */ StszAtom),
/* harmony export */   SttsAtom: () => (/* binding */ SttsAtom),
/* harmony export */   TimeToSampleToken: () => (/* binding */ TimeToSampleToken),
/* harmony export */   TrackHeaderAtom: () => (/* binding */ TrackHeaderAtom),
/* harmony export */   ftyp: () => (/* binding */ ftyp),
/* harmony export */   mhdr: () => (/* binding */ mhdr),
/* harmony export */   tkhd: () => (/* binding */ tkhd)
/* harmony export */ });
/* harmony import */ var token_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! token-types */ "./node_modules/token-types/lib/index.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");
/* harmony import */ var _common_FourCC_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/FourCC.js */ "./node_modules/music-metadata/lib/common/FourCC.js");
/* harmony import */ var _ParseError_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../ParseError.js */ "./node_modules/music-metadata/lib/ParseError.js");




const debug = debug__WEBPACK_IMPORTED_MODULE_1__('music-metadata:parser:MP4:atom');
class Mp4ContentError extends (0,_ParseError_js__WEBPACK_IMPORTED_MODULE_2__.makeUnexpectedFileContentError)('MP4') {
}
const Header = {
    len: 8,
    get: (buf, off) => {
        const length = token_types__WEBPACK_IMPORTED_MODULE_0__.UINT32_BE.get(buf, off);
        if (length < 0)
            throw new Mp4ContentError('Invalid atom header length');
        return {
            length: BigInt(length),
            name: new token_types__WEBPACK_IMPORTED_MODULE_0__.StringType(4, 'latin1').get(buf, off + 4)
        };
    },
    put: (buf, off, hdr) => {
        token_types__WEBPACK_IMPORTED_MODULE_0__.UINT32_BE.put(buf, off, Number(hdr.length));
        return _common_FourCC_js__WEBPACK_IMPORTED_MODULE_3__.FourCcToken.put(buf, off + 4, hdr.name);
    }
};
/**
 * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap1/qtff1.html#//apple_ref/doc/uid/TP40000939-CH203-38190
 */
const ExtendedSize = token_types__WEBPACK_IMPORTED_MODULE_0__.UINT64_BE;
const ftyp = {
    len: 4,
    get: (buf, off) => {
        return {
            type: new token_types__WEBPACK_IMPORTED_MODULE_0__.StringType(4, 'ascii').get(buf, off)
        };
    }
};
const tkhd = {
    len: 4,
    get: (buf, off) => {
        return {
            type: new token_types__WEBPACK_IMPORTED_MODULE_0__.StringType(4, 'ascii').get(buf, off)
        };
    }
};
/**
 * Token: Movie Header Atom
 */
const mhdr = {
    len: 8,
    get: (buf, off) => {
        return {
            version: token_types__WEBPACK_IMPORTED_MODULE_0__.UINT8.get(buf, off),
            flags: token_types__WEBPACK_IMPORTED_MODULE_0__.UINT24_BE.get(buf, off + 1),
            nextItemID: token_types__WEBPACK_IMPORTED_MODULE_0__.UINT32_BE.get(buf, off + 4)
        };
    }
};
/**
 * Base class for 'fixed' length atoms.
 * In some cases these atoms are longer then the sum of the described fields.
 * Issue: https://github.com/Borewit/music-metadata/issues/120
 */
class FixedLengthAtom {
    /**
     *
     * @param {number} len Length as specified in the size field
     * @param {number} expLen Total length of sum of specified fields in the standard
     * @param atomId Atom ID
     */
    constructor(len, expLen, atomId) {
        if (len < expLen) {
            throw new Mp4ContentError(`Atom ${atomId} expected to be ${expLen}, but specifies ${len} bytes long.`);
        }
        if (len > expLen) {
            debug(`Warning: atom ${atomId} expected to be ${expLen}, but was actually ${len} bytes long.`);
        }
        this.len = len;
    }
}
/**
 * Timestamp stored in seconds since Mac Epoch (1 January 1904)
 */
const SecondsSinceMacEpoch = {
    len: 4,
    get: (buf, off) => {
        const secondsSinceUnixEpoch = token_types__WEBPACK_IMPORTED_MODULE_0__.UINT32_BE.get(buf, off) - 2082844800;
        return new Date(secondsSinceUnixEpoch * 1000);
    }
};
/**
 * Token: Media Header Atom
 * Ref:
 * - https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-SW34
 * - https://wiki.multimedia.cx/index.php/QuickTime_container#mdhd
 */
class MdhdAtom extends FixedLengthAtom {
    constructor(len) {
        super(len, 24, 'mdhd');
    }
    get(buf, off) {
        return {
            version: token_types__WEBPACK_IMPORTED_MODULE_0__.UINT8.get(buf, off + 0),
            flags: token_types__WEBPACK_IMPORTED_MODULE_0__.UINT24_BE.get(buf, off + 1),
            creationTime: SecondsSinceMacEpoch.get(buf, off + 4),
            modificationTime: SecondsSinceMacEpoch.get(buf, off + 8),
            timeScale: token_types__WEBPACK_IMPORTED_MODULE_0__.UINT32_BE.get(buf, off + 12),
            duration: token_types__WEBPACK_IMPORTED_MODULE_0__.UINT32_BE.get(buf, off + 16),
            language: token_types__WEBPACK_IMPORTED_MODULE_0__.UINT16_BE.get(buf, off + 20),
            quality: token_types__WEBPACK_IMPORTED_MODULE_0__.UINT16_BE.get(buf, off + 22)
        };
    }
}
/**
 * Token: Movie Header Atom
 */
class MvhdAtom extends FixedLengthAtom {
    constructor(len) {
        super(len, 100, 'mvhd');
    }
    get(buf, off) {
        return {
            version: token_types__WEBPACK_IMPORTED_MODULE_0__.UINT8.get(buf, off),
            flags: token_types__WEBPACK_IMPORTED_MODULE_0__.UINT24_BE.get(buf, off + 1),
            creationTime: SecondsSinceMacEpoch.get(buf, off + 4),
            modificationTime: SecondsSinceMacEpoch.get(buf, off + 8),
            timeScale: token_types__WEBPACK_IMPORTED_MODULE_0__.UINT32_BE.get(buf, off + 12),
            duration: token_types__WEBPACK_IMPORTED_MODULE_0__.UINT32_BE.get(buf, off + 16),
            preferredRate: token_types__WEBPACK_IMPORTED_MODULE_0__.UINT32_BE.get(buf, off + 20),
            preferredVolume: token_types__WEBPACK_IMPORTED_MODULE_0__.UINT16_BE.get(buf, off + 24),
            // ignore reserver: 10 bytes
            // ignore matrix structure: 36 bytes
            previewTime: token_types__WEBPACK_IMPORTED_MODULE_0__.UINT32_BE.get(buf, off + 72),
            previewDuration: token_types__WEBPACK_IMPORTED_MODULE_0__.UINT32_BE.get(buf, off + 76),
            posterTime: token_types__WEBPACK_IMPORTED_MODULE_0__.UINT32_BE.get(buf, off + 80),
            selectionTime: token_types__WEBPACK_IMPORTED_MODULE_0__.UINT32_BE.get(buf, off + 84),
            selectionDuration: token_types__WEBPACK_IMPORTED_MODULE_0__.UINT32_BE.get(buf, off + 88),
            currentTime: token_types__WEBPACK_IMPORTED_MODULE_0__.UINT32_BE.get(buf, off + 92),
            nextTrackID: token_types__WEBPACK_IMPORTED_MODULE_0__.UINT32_BE.get(buf, off + 96)
        };
    }
}
/**
 * Data Atom Structure
 */
class DataAtom {
    constructor(len) {
        this.len = len;
    }
    get(buf, off) {
        return {
            type: {
                set: token_types__WEBPACK_IMPORTED_MODULE_0__.UINT8.get(buf, off + 0),
                type: token_types__WEBPACK_IMPORTED_MODULE_0__.UINT24_BE.get(buf, off + 1)
            },
            locale: token_types__WEBPACK_IMPORTED_MODULE_0__.UINT24_BE.get(buf, off + 4),
            value: new token_types__WEBPACK_IMPORTED_MODULE_0__.Uint8ArrayType(this.len - 8).get(buf, off + 8)
        };
    }
}
/**
 * Data Atom Structure
 * Ref: https://developer.apple.com/library/content/documentation/QuickTime/QTFF/Metadata/Metadata.html#//apple_ref/doc/uid/TP40000939-CH1-SW31
 */
class NameAtom {
    constructor(len) {
        this.len = len;
    }
    get(buf, off) {
        return {
            version: token_types__WEBPACK_IMPORTED_MODULE_0__.UINT8.get(buf, off),
            flags: token_types__WEBPACK_IMPORTED_MODULE_0__.UINT24_BE.get(buf, off + 1),
            name: new token_types__WEBPACK_IMPORTED_MODULE_0__.StringType(this.len - 4, 'utf-8').get(buf, off + 4)
        };
    }
}
/**
 * Track Header Atoms structure
 * Ref: https://developer.apple.com/library/content/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25550
 */
class TrackHeaderAtom {
    constructor(len) {
        this.len = len;
    }
    get(buf, off) {
        return {
            version: token_types__WEBPACK_IMPORTED_MODULE_0__.UINT8.get(buf, off),
            flags: token_types__WEBPACK_IMPORTED_MODULE_0__.UINT24_BE.get(buf, off + 1),
            creationTime: SecondsSinceMacEpoch.get(buf, off + 4),
            modificationTime: SecondsSinceMacEpoch.get(buf, off + 8),
            trackId: token_types__WEBPACK_IMPORTED_MODULE_0__.UINT32_BE.get(buf, off + 12),
            // reserved 4 bytes
            duration: token_types__WEBPACK_IMPORTED_MODULE_0__.UINT32_BE.get(buf, off + 20),
            layer: token_types__WEBPACK_IMPORTED_MODULE_0__.UINT16_BE.get(buf, off + 24),
            alternateGroup: token_types__WEBPACK_IMPORTED_MODULE_0__.UINT16_BE.get(buf, off + 26),
            volume: token_types__WEBPACK_IMPORTED_MODULE_0__.UINT16_BE.get(buf, off + 28) // ToDo: fixed point
            // ToDo: add remaining fields
        };
    }
}
/**
 * Atom: Sample Description Atom ('stsd')
 * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25691
 */
const stsdHeader = {
    len: 8,
    get: (buf, off) => {
        return {
            version: token_types__WEBPACK_IMPORTED_MODULE_0__.UINT8.get(buf, off),
            flags: token_types__WEBPACK_IMPORTED_MODULE_0__.UINT24_BE.get(buf, off + 1),
            numberOfEntries: token_types__WEBPACK_IMPORTED_MODULE_0__.UINT32_BE.get(buf, off + 4)
        };
    }
};
/**
 * Atom: Sample Description Atom ('stsd')
 * Ref: https://developer.apple.com/documentation/quicktime-file-format/sample_description_atom
 */
class SampleDescriptionTable {
    constructor(len) {
        this.len = len;
    }
    get(buf, off) {
        const descrLen = this.len - 12;
        return {
            dataFormat: _common_FourCC_js__WEBPACK_IMPORTED_MODULE_3__.FourCcToken.get(buf, off),
            dataReferenceIndex: token_types__WEBPACK_IMPORTED_MODULE_0__.UINT16_BE.get(buf, off + 10),
            description: descrLen > 0 ? new token_types__WEBPACK_IMPORTED_MODULE_0__.Uint8ArrayType(descrLen).get(buf, off + 12) : undefined
        };
    }
}
/**
 * Atom: Sample-description Atom ('stsd')
 * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25691
 */
class StsdAtom {
    constructor(len) {
        this.len = len;
    }
    get(buf, off) {
        const header = stsdHeader.get(buf, off);
        off += stsdHeader.len;
        const table = [];
        for (let n = 0; n < header.numberOfEntries; ++n) {
            const size = token_types__WEBPACK_IMPORTED_MODULE_0__.UINT32_BE.get(buf, off); // Sample description size
            off += token_types__WEBPACK_IMPORTED_MODULE_0__.UINT32_BE.len;
            table.push(new SampleDescriptionTable(size - token_types__WEBPACK_IMPORTED_MODULE_0__.UINT32_BE.len).get(buf, off));
            off += size;
        }
        return {
            header,
            table
        };
    }
}
/**
 * Common Sound Sample Description (version & revision)
 * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap3/qtff3.html#//apple_ref/doc/uid/TP40000939-CH205-57317
 */
const SoundSampleDescriptionVersion = {
    len: 8,
    get(buf, off) {
        return {
            version: token_types__WEBPACK_IMPORTED_MODULE_0__.INT16_BE.get(buf, off),
            revision: token_types__WEBPACK_IMPORTED_MODULE_0__.INT16_BE.get(buf, off + 2),
            vendor: token_types__WEBPACK_IMPORTED_MODULE_0__.INT32_BE.get(buf, off + 4)
        };
    }
};
/**
 * Sound Sample Description (Version 0)
 * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap3/qtff3.html#//apple_ref/doc/uid/TP40000939-CH205-130736
 */
const SoundSampleDescriptionV0 = {
    len: 12,
    get(buf, off) {
        return {
            numAudioChannels: token_types__WEBPACK_IMPORTED_MODULE_0__.INT16_BE.get(buf, off + 0),
            sampleSize: token_types__WEBPACK_IMPORTED_MODULE_0__.INT16_BE.get(buf, off + 2),
            compressionId: token_types__WEBPACK_IMPORTED_MODULE_0__.INT16_BE.get(buf, off + 4),
            packetSize: token_types__WEBPACK_IMPORTED_MODULE_0__.INT16_BE.get(buf, off + 6),
            sampleRate: token_types__WEBPACK_IMPORTED_MODULE_0__.UINT16_BE.get(buf, off + 8) + token_types__WEBPACK_IMPORTED_MODULE_0__.UINT16_BE.get(buf, off + 10) / 10000
        };
    }
};
class SimpleTableAtom {
    constructor(len, token) {
        this.len = len;
        this.token = token;
    }
    get(buf, off) {
        const nrOfEntries = token_types__WEBPACK_IMPORTED_MODULE_0__.INT32_BE.get(buf, off + 4);
        return {
            version: token_types__WEBPACK_IMPORTED_MODULE_0__.INT8.get(buf, off + 0),
            flags: token_types__WEBPACK_IMPORTED_MODULE_0__.INT24_BE.get(buf, off + 1),
            numberOfEntries: nrOfEntries,
            entries: readTokenTable(buf, this.token, off + 8, this.len - 8, nrOfEntries)
        };
    }
}
const TimeToSampleToken = {
    len: 8,
    get(buf, off) {
        return {
            count: token_types__WEBPACK_IMPORTED_MODULE_0__.INT32_BE.get(buf, off + 0),
            duration: token_types__WEBPACK_IMPORTED_MODULE_0__.INT32_BE.get(buf, off + 4)
        };
    }
};
/**
 * Time-to-sample('stts') atom.
 * Store duration information for a media’s samples.
 * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25696
 */
class SttsAtom extends SimpleTableAtom {
    constructor(len) {
        super(len, TimeToSampleToken);
    }
}
const SampleToChunkToken = {
    len: 12,
    get(buf, off) {
        return {
            firstChunk: token_types__WEBPACK_IMPORTED_MODULE_0__.INT32_BE.get(buf, off),
            samplesPerChunk: token_types__WEBPACK_IMPORTED_MODULE_0__.INT32_BE.get(buf, off + 4),
            sampleDescriptionId: token_types__WEBPACK_IMPORTED_MODULE_0__.INT32_BE.get(buf, off + 8)
        };
    }
};
/**
 * Sample-to-Chunk ('stsc') atom interface
 * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25706
 */
class StscAtom extends SimpleTableAtom {
    constructor(len) {
        super(len, SampleToChunkToken);
    }
}
/**
 * Sample-size ('stsz') atom
 * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25710
 */
class StszAtom {
    constructor(len) {
        this.len = len;
    }
    get(buf, off) {
        const nrOfEntries = token_types__WEBPACK_IMPORTED_MODULE_0__.INT32_BE.get(buf, off + 8);
        return {
            version: token_types__WEBPACK_IMPORTED_MODULE_0__.INT8.get(buf, off),
            flags: token_types__WEBPACK_IMPORTED_MODULE_0__.INT24_BE.get(buf, off + 1),
            sampleSize: token_types__WEBPACK_IMPORTED_MODULE_0__.INT32_BE.get(buf, off + 4),
            numberOfEntries: nrOfEntries,
            entries: readTokenTable(buf, token_types__WEBPACK_IMPORTED_MODULE_0__.INT32_BE, off + 12, this.len - 12, nrOfEntries)
        };
    }
}
/**
 * Chunk offset atom, 'stco'
 * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25715
 */
class StcoAtom extends SimpleTableAtom {
    constructor(len) {
        super(len, token_types__WEBPACK_IMPORTED_MODULE_0__.INT32_BE);
        this.len = len;
    }
}
/**
 * Token used to decode text-track from 'mdat' atom (raw data stream)
 */
class ChapterText {
    constructor(len) {
        this.len = len;
    }
    get(buf, off) {
        const titleLen = token_types__WEBPACK_IMPORTED_MODULE_0__.INT16_BE.get(buf, off + 0);
        const str = new token_types__WEBPACK_IMPORTED_MODULE_0__.StringType(titleLen, 'utf-8');
        return str.get(buf, off + 2);
    }
}
function readTokenTable(buf, token, off, remainingLen, numberOfEntries) {
    debug(`remainingLen=${remainingLen}, numberOfEntries=${numberOfEntries} * token-len=${token.len}`);
    if (remainingLen === 0)
        return [];
    if (remainingLen !== numberOfEntries * token.len)
        throw new Mp4ContentError('mismatch number-of-entries with remaining atom-length');
    const entries = [];
    // parse offset-table
    for (let n = 0; n < numberOfEntries; ++n) {
        entries.push(token.get(buf, off));
        off += token.len;
    }
    return entries;
}
//# sourceMappingURL=AtomToken.js.map

/***/ }),

/***/ "./node_modules/music-metadata/lib/mp4/MP4Parser.js":
/*!**********************************************************!*\
  !*** ./node_modules/music-metadata/lib/mp4/MP4Parser.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MP4Parser: () => (/* binding */ MP4Parser)
/* harmony export */ });
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");
/* harmony import */ var token_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! token-types */ "./node_modules/token-types/lib/index.js");
/* harmony import */ var _common_BasicParser_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/BasicParser.js */ "./node_modules/music-metadata/lib/common/BasicParser.js");
/* harmony import */ var _id3v1_ID3v1Parser_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../id3v1/ID3v1Parser.js */ "./node_modules/music-metadata/lib/id3v1/ID3v1Parser.js");
/* harmony import */ var _Atom_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Atom.js */ "./node_modules/music-metadata/lib/mp4/Atom.js");
/* harmony import */ var _AtomToken_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AtomToken.js */ "./node_modules/music-metadata/lib/mp4/AtomToken.js");
/* harmony import */ var _type_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../type.js */ "./node_modules/music-metadata/lib/matroska/types.js");
/* harmony import */ var uint8array_extras__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! uint8array-extras */ "./node_modules/uint8array-extras/index.js");









const debug = debug__WEBPACK_IMPORTED_MODULE_0__('music-metadata:parser:MP4');
const tagFormat = 'iTunes';
const encoderDict = {
    raw: {
        lossy: false,
        format: 'raw'
    },
    MAC3: {
        lossy: true,
        format: 'MACE 3:1'
    },
    MAC6: {
        lossy: true,
        format: 'MACE 6:1'
    },
    ima4: {
        lossy: true,
        format: 'IMA 4:1'
    },
    ulaw: {
        lossy: true,
        format: 'uLaw 2:1'
    },
    alaw: {
        lossy: true,
        format: 'uLaw 2:1'
    },
    Qclp: {
        lossy: true,
        format: 'QUALCOMM PureVoice'
    },
    '.mp3': {
        lossy: true,
        format: 'MPEG-1 layer 3'
    },
    alac: {
        lossy: false,
        format: 'ALAC'
    },
    'ac-3': {
        lossy: true,
        format: 'AC-3'
    },
    mp4a: {
        lossy: true,
        format: 'MPEG-4/AAC'
    },
    mp4s: {
        lossy: true,
        format: 'MP4S'
    },
    // Closed Captioning Media, https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap3/qtff3.html#//apple_ref/doc/uid/TP40000939-CH205-SW87
    c608: {
        lossy: true,
        format: 'CEA-608'
    },
    c708: {
        lossy: true,
        format: 'CEA-708'
    }
};
function distinct(value, index, self) {
    return self.indexOf(value) === index;
}
/*
 * Parser for the MP4 (MPEG-4 Part 14) container format
 * Standard: ISO/IEC 14496-14
 * supporting:
 * - QuickTime container
 * - MP4 File Format
 * - 3GPP file format
 * - 3GPP2 file format
 *
 * MPEG-4 Audio / Part 3 (.m4a)& MPEG 4 Video (m4v, mp4) extension.
 * Support for Apple iTunes tags as found in a M4A/M4V files.
 * Ref:
 *   https://en.wikipedia.org/wiki/ISO_base_media_file_format
 *   https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/Metadata/Metadata.html
 *   http://atomicparsley.sourceforge.net/mpeg-4files.html
 *   https://github.com/sergiomb2/libmp4v2/wiki/iTunesMetadata
 *   https://wiki.multimedia.cx/index.php/QuickTime_container
 */
class MP4Parser extends _common_BasicParser_js__WEBPACK_IMPORTED_MODULE_2__.BasicParser {
    constructor() {
        super(...arguments);
        this.tracks = [];
        this.atomParsers = {
            /**
             * Parse movie header (mvhd) atom
             * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-56313
             */
            mvhd: async (len) => {
                const mvhd = await this.tokenizer.readToken(new _AtomToken_js__WEBPACK_IMPORTED_MODULE_3__.MvhdAtom(len));
                this.metadata.setFormat('creationTime', mvhd.creationTime);
                this.metadata.setFormat('modificationTime', mvhd.modificationTime);
            },
            /**
             * Parse media header (mdhd) atom
             * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25615
             */
            mdhd: async (len) => {
                const mdhd_data = await this.tokenizer.readToken(new _AtomToken_js__WEBPACK_IMPORTED_MODULE_3__.MdhdAtom(len));
                // this.parse_mxhd(mdhd_data, this.currentTrack);
                const td = this.getTrackDescription();
                td.creationTime = mdhd_data.creationTime;
                td.modificationTime = mdhd_data.modificationTime;
                td.timeScale = mdhd_data.timeScale;
                td.duration = mdhd_data.duration;
            },
            chap: async (len) => {
                const td = this.getTrackDescription();
                const trackIds = [];
                while (len >= token_types__WEBPACK_IMPORTED_MODULE_1__.UINT32_BE.len) {
                    trackIds.push(await this.tokenizer.readNumber(token_types__WEBPACK_IMPORTED_MODULE_1__.UINT32_BE));
                    len -= token_types__WEBPACK_IMPORTED_MODULE_1__.UINT32_BE.len;
                }
                td.chapterList = trackIds;
            },
            tkhd: async (len) => {
                const track = (await this.tokenizer.readToken(new _AtomToken_js__WEBPACK_IMPORTED_MODULE_3__.TrackHeaderAtom(len)));
                this.tracks.push(track);
            },
            /**
             * Parse mdat atom.
             * Will scan for chapters
             */
            mdat: async (len) => {
                this.audioLengthInBytes = len;
                this.calculateBitRate();
                if (this.options.includeChapters) {
                    const trackWithChapters = this.tracks.filter(track => track.chapterList);
                    if (trackWithChapters.length === 1) {
                        const chapterTrackIds = trackWithChapters[0].chapterList;
                        const chapterTracks = this.tracks.filter(track => chapterTrackIds.indexOf(track.trackId) !== -1);
                        if (chapterTracks.length === 1) {
                            return this.parseChapterTrack(chapterTracks[0], trackWithChapters[0], len);
                        }
                    }
                }
                await this.tokenizer.ignore(len);
            },
            ftyp: async (len) => {
                const types = [];
                while (len > 0) {
                    const ftype = await this.tokenizer.readToken(_AtomToken_js__WEBPACK_IMPORTED_MODULE_3__.ftyp);
                    len -= _AtomToken_js__WEBPACK_IMPORTED_MODULE_3__.ftyp.len;
                    const value = ftype.type.replace(/\W/g, '');
                    if (value.length > 0) {
                        types.push(value); // unshift for backward compatibility
                    }
                }
                debug(`ftyp: ${types.join('/')}`);
                const x = types.filter(distinct).join('/');
                this.metadata.setFormat('container', x);
            },
            /**
             * Parse sample description atom
             */
            stsd: async (len) => {
                const stsd = await this.tokenizer.readToken(new _AtomToken_js__WEBPACK_IMPORTED_MODULE_3__.StsdAtom(len));
                const trackDescription = this.getTrackDescription();
                trackDescription.soundSampleDescription = stsd.table.map(dfEntry => this.parseSoundSampleDescription(dfEntry));
            },
            /**
             * sample-to-Chunk Atoms
             */
            stsc: async (len) => {
                const stsc = await this.tokenizer.readToken(new _AtomToken_js__WEBPACK_IMPORTED_MODULE_3__.StscAtom(len));
                this.getTrackDescription().sampleToChunkTable = stsc.entries;
            },
            /**
             * time-to-sample table
             */
            stts: async (len) => {
                const stts = await this.tokenizer.readToken(new _AtomToken_js__WEBPACK_IMPORTED_MODULE_3__.SttsAtom(len));
                this.getTrackDescription().timeToSampleTable = stts.entries;
            },
            /**
             * Parse sample-sizes atom ('stsz')
             */
            stsz: async (len) => {
                const stsz = await this.tokenizer.readToken(new _AtomToken_js__WEBPACK_IMPORTED_MODULE_3__.StszAtom(len));
                const td = this.getTrackDescription();
                td.sampleSize = stsz.sampleSize;
                td.sampleSizeTable = stsz.entries;
            },
            /**
             * Parse chunk-offset atom ('stco')
             */
            stco: async (len) => {
                const stco = await this.tokenizer.readToken(new _AtomToken_js__WEBPACK_IMPORTED_MODULE_3__.StcoAtom(len));
                this.getTrackDescription().chunkOffsetTable = stco.entries; // remember chunk offsets
            },
            date: async (len) => {
                const date = await this.tokenizer.readToken(new token_types__WEBPACK_IMPORTED_MODULE_1__.StringType(len, 'utf-8'));
                await this.addTag('date', date);
            }
        };
    }
    static read_BE_Integer(array, signed) {
        const integerType = (signed ? 'INT' : 'UINT') + array.length * 8 + (array.length > 1 ? '_BE' : '');
        const token = token_types__WEBPACK_IMPORTED_MODULE_1__[integerType];
        if (!token) {
            throw new _AtomToken_js__WEBPACK_IMPORTED_MODULE_3__.Mp4ContentError(`Token for integer type not found: "${integerType}"`);
        }
        return Number(token.get(array, 0));
    }
    async parse() {
        this.tracks = [];
        let remainingFileSize = this.tokenizer.fileInfo.size || 0;
        while (!this.tokenizer.fileInfo.size || remainingFileSize > 0) {
            try {
                const token = await this.tokenizer.peekToken(_AtomToken_js__WEBPACK_IMPORTED_MODULE_3__.Header);
                if (token.name === '\0\0\0\0') {
                    const errMsg = `Error at offset=${this.tokenizer.position}: box.id=0`;
                    debug(errMsg);
                    this.addWarning(errMsg);
                    break;
                }
            }
            catch (error) {
                if (error instanceof Error) {
                    const errMsg = `Error at offset=${this.tokenizer.position}: ${error.message}`;
                    debug(errMsg);
                    this.addWarning(errMsg);
                }
                else
                    throw error;
                break;
            }
            const rootAtom = await _Atom_js__WEBPACK_IMPORTED_MODULE_4__.Atom.readAtom(this.tokenizer, (atom, remaining) => this.handleAtom(atom, remaining), null, remainingFileSize);
            remainingFileSize -= rootAtom.header.length === BigInt(0) ? remainingFileSize : Number(rootAtom.header.length);
        }
        // Post process metadata
        const formatList = [];
        this.tracks.forEach(track => {
            const trackFormats = [];
            track.soundSampleDescription.forEach(ssd => {
                const streamInfo = {};
                const encoderInfo = encoderDict[ssd.dataFormat];
                if (encoderInfo) {
                    trackFormats.push(encoderInfo.format);
                    streamInfo.codecName = encoderInfo.format;
                }
                else {
                    streamInfo.codecName = `<${ssd.dataFormat}>`;
                }
                if (ssd.description) {
                    const { description } = ssd;
                    if (description.sampleRate > 0) {
                        streamInfo.type = _type_js__WEBPACK_IMPORTED_MODULE_5__.TrackType.audio;
                        streamInfo.audio = {
                            samplingFrequency: description.sampleRate,
                            bitDepth: description.sampleSize,
                            channels: description.numAudioChannels
                        };
                    }
                }
                this.metadata.addStreamInfo(streamInfo);
            });
            if (trackFormats.length >= 1) {
                formatList.push(trackFormats.join('/'));
            }
        });
        if (formatList.length > 0) {
            this.metadata.setFormat('codec', formatList.filter(distinct).join('+'));
        }
        const audioTracks = this.tracks.filter(track => {
            return track.soundSampleDescription.length >= 1 && track.soundSampleDescription[0].description && track.soundSampleDescription[0].description.numAudioChannels > 0;
        });
        if (audioTracks.length >= 1) {
            const audioTrack = audioTracks[0];
            if (audioTrack.timeScale > 0) {
                const duration = audioTrack.duration / audioTrack.timeScale; // calculate duration in seconds
                this.metadata.setFormat('duration', duration);
            }
            const ssd = audioTrack.soundSampleDescription[0];
            if (ssd.description) {
                this.metadata.setFormat('sampleRate', ssd.description.sampleRate);
                this.metadata.setFormat('bitsPerSample', ssd.description.sampleSize);
                this.metadata.setFormat('numberOfChannels', ssd.description.numAudioChannels);
                if (audioTrack.timeScale === 0 && audioTrack.timeToSampleTable.length > 0) {
                    const totalSampleSize = audioTrack.timeToSampleTable
                        .map(ttstEntry => ttstEntry.count * ttstEntry.duration)
                        .reduce((total, sampleSize) => total + sampleSize);
                    const duration = totalSampleSize / ssd.description.sampleRate;
                    this.metadata.setFormat('duration', duration);
                }
            }
            const encoderInfo = encoderDict[ssd.dataFormat];
            if (encoderInfo) {
                this.metadata.setFormat('lossless', !encoderInfo.lossy);
            }
            this.calculateBitRate();
        }
    }
    async handleAtom(atom, remaining) {
        if (atom.parent) {
            switch (atom.parent.header.name) {
                case 'ilst':
                case '<id>':
                    return this.parseMetadataItemData(atom);
            }
        }
        // const payloadLength = atom.getPayloadLength(remaining);
        if (this.atomParsers[atom.header.name]) {
            return this.atomParsers[atom.header.name](remaining);
        }
        debug(`No parser for atom path=${atom.atomPath}, payload-len=${remaining}, ignoring atom`);
        await this.tokenizer.ignore(remaining);
    }
    getTrackDescription() {
        return this.tracks[this.tracks.length - 1];
    }
    calculateBitRate() {
        if (this.audioLengthInBytes && this.metadata.format.duration) {
            this.metadata.setFormat('bitrate', 8 * this.audioLengthInBytes / this.metadata.format.duration);
        }
    }
    async addTag(id, value) {
        await this.metadata.addTag(tagFormat, id, value);
    }
    addWarning(message) {
        debug(`Warning: ${message}`);
        this.metadata.addWarning(message);
    }
    /**
     * Parse data of Meta-item-list-atom (item of 'ilst' atom)
     * @param metaAtom
     * Ref: https://developer.apple.com/library/content/documentation/QuickTime/QTFF/Metadata/Metadata.html#//apple_ref/doc/uid/TP40000939-CH1-SW8
     */
    parseMetadataItemData(metaAtom) {
        let tagKey = metaAtom.header.name;
        return metaAtom.readAtoms(this.tokenizer, async (child, remaining) => {
            const payLoadLength = child.getPayloadLength(remaining);
            switch (child.header.name) {
                case 'data': // value atom
                    return this.parseValueAtom(tagKey, child);
                case 'name': // name atom (optional)
                case 'mean':
                case 'rate': {
                    const name = await this.tokenizer.readToken(new _AtomToken_js__WEBPACK_IMPORTED_MODULE_3__.NameAtom(payLoadLength));
                    tagKey += `:${name.name}`;
                    break;
                }
                default: {
                    const uint8Array = await this.tokenizer.readToken(new token_types__WEBPACK_IMPORTED_MODULE_1__.Uint8ArrayType(payLoadLength));
                    this.addWarning(`Unsupported meta-item: ${tagKey}[${child.header.name}] => value=${(0,uint8array_extras__WEBPACK_IMPORTED_MODULE_6__.uint8ArrayToHex)(uint8Array)} ascii=${(0,uint8array_extras__WEBPACK_IMPORTED_MODULE_6__.uint8ArrayToString)(uint8Array, 'ascii')}`);
                }
            }
        }, metaAtom.getPayloadLength(0));
    }
    async parseValueAtom(tagKey, metaAtom) {
        const dataAtom = await this.tokenizer.readToken(new _AtomToken_js__WEBPACK_IMPORTED_MODULE_3__.DataAtom(Number(metaAtom.header.length) - _AtomToken_js__WEBPACK_IMPORTED_MODULE_3__.Header.len));
        if (dataAtom.type.set !== 0) {
            throw new _AtomToken_js__WEBPACK_IMPORTED_MODULE_3__.Mp4ContentError(`Unsupported type-set != 0: ${dataAtom.type.set}`);
        }
        // Use well-known-type table
        // Ref: https://developer.apple.com/library/content/documentation/QuickTime/QTFF/Metadata/Metadata.html#//apple_ref/doc/uid/TP40000939-CH1-SW35
        switch (dataAtom.type.type) {
            case 0: // reserved: Reserved for use where no type needs to be indicated
                switch (tagKey) {
                    case 'trkn':
                    case 'disk': {
                        const num = token_types__WEBPACK_IMPORTED_MODULE_1__.UINT8.get(dataAtom.value, 3);
                        const of = token_types__WEBPACK_IMPORTED_MODULE_1__.UINT8.get(dataAtom.value, 5);
                        // console.log("  %s[data] = %s/%s", tagKey, num, of);
                        await this.addTag(tagKey, `${num}/${of}`);
                        break;
                    }
                    case 'gnre': {
                        const genreInt = token_types__WEBPACK_IMPORTED_MODULE_1__.UINT8.get(dataAtom.value, 1);
                        const genreStr = _id3v1_ID3v1Parser_js__WEBPACK_IMPORTED_MODULE_7__.Genres[genreInt - 1];
                        // console.log("  %s[data] = %s", tagKey, genreStr);
                        await this.addTag(tagKey, genreStr);
                        break;
                    }
                    case 'rate': {
                        const rate = new TextDecoder('ascii').decode(dataAtom.value);
                        await this.addTag(tagKey, rate);
                        break;
                    }
                    default:
                        debug(`unknown proprietary value type for: ${metaAtom.atomPath}`);
                }
                break;
            case 1: // UTF-8: Without any count or NULL terminator
            case 18: // Unknown: Found in m4b in combination with a '©gen' tag
                await this.addTag(tagKey, new TextDecoder('utf-8').decode(dataAtom.value));
                break;
            case 13: // JPEG
                if (this.options.skipCovers)
                    break;
                await this.addTag(tagKey, {
                    format: 'image/jpeg',
                    data: Uint8Array.from(dataAtom.value)
                });
                break;
            case 14: // PNG
                if (this.options.skipCovers)
                    break;
                await this.addTag(tagKey, {
                    format: 'image/png',
                    data: Uint8Array.from(dataAtom.value)
                });
                break;
            case 21: // BE Signed Integer
                await this.addTag(tagKey, MP4Parser.read_BE_Integer(dataAtom.value, true));
                break;
            case 22: // BE Unsigned Integer
                await this.addTag(tagKey, MP4Parser.read_BE_Integer(dataAtom.value, false));
                break;
            case 65: // An 8-bit signed integer
                await this.addTag(tagKey, token_types__WEBPACK_IMPORTED_MODULE_1__.UINT8.get(dataAtom.value, 0));
                break;
            case 66: // A big-endian 16-bit signed integer
                await this.addTag(tagKey, token_types__WEBPACK_IMPORTED_MODULE_1__.UINT16_BE.get(dataAtom.value, 0));
                break;
            case 67: // A big-endian 32-bit signed integer
                await this.addTag(tagKey, token_types__WEBPACK_IMPORTED_MODULE_1__.UINT32_BE.get(dataAtom.value, 0));
                break;
            default:
                this.addWarning(`atom key=${tagKey}, has unknown well-known-type (data-type): ${dataAtom.type.type}`);
        }
    }
    /**
     * @param sampleDescription
     * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap3/qtff3.html#//apple_ref/doc/uid/TP40000939-CH205-128916
     */
    parseSoundSampleDescription(sampleDescription) {
        const ssd = {
            dataFormat: sampleDescription.dataFormat,
            dataReferenceIndex: sampleDescription.dataReferenceIndex
        };
        let offset = 0;
        if (sampleDescription.description) {
            const version = _AtomToken_js__WEBPACK_IMPORTED_MODULE_3__.SoundSampleDescriptionVersion.get(sampleDescription.description, offset);
            offset += _AtomToken_js__WEBPACK_IMPORTED_MODULE_3__.SoundSampleDescriptionVersion.len;
            if (version.version === 0 || version.version === 1) {
                // Sound Sample Description (Version 0)
                ssd.description = _AtomToken_js__WEBPACK_IMPORTED_MODULE_3__.SoundSampleDescriptionV0.get(sampleDescription.description, offset);
            }
            else {
                debug(`Warning: sound-sample-description ${version} not implemented`);
            }
        }
        return ssd;
    }
    async parseChapterTrack(chapterTrack, track, len) {
        if (!chapterTrack.sampleSize) {
            if (chapterTrack.chunkOffsetTable.length !== chapterTrack.sampleSizeTable.length)
                throw new Error('Expected equal chunk-offset-table & sample-size-table length.');
        }
        const chapters = [];
        for (let i = 0; i < chapterTrack.chunkOffsetTable.length && len > 0; ++i) {
            const start = chapterTrack.timeToSampleTable
                .slice(0, i)
                .reduce((acc, cur) => acc + cur.duration, 0);
            const chunkOffset = chapterTrack.chunkOffsetTable[i];
            const nextChunkLen = chunkOffset - this.tokenizer.position;
            const sampleSize = chapterTrack.sampleSize > 0 ? chapterTrack.sampleSize : chapterTrack.sampleSizeTable[i];
            len -= nextChunkLen + sampleSize;
            if (len < 0)
                throw new _AtomToken_js__WEBPACK_IMPORTED_MODULE_3__.Mp4ContentError('Chapter chunk exceeding token length');
            await this.tokenizer.ignore(nextChunkLen);
            const title = await this.tokenizer.readToken(new _AtomToken_js__WEBPACK_IMPORTED_MODULE_3__.ChapterText(sampleSize));
            debug(`Chapter ${i + 1}: ${title}`);
            const chapter = {
                title,
                timeScale: chapterTrack.timeScale,
                start,
                sampleOffset: this.findSampleOffset(track, this.tokenizer.position)
            };
            debug(`Chapter title=${chapter.title}, offset=${chapter.sampleOffset}/${this.tracks[0].duration}`);
            chapters.push(chapter);
        }
        this.metadata.setFormat('chapters', chapters);
        await this.tokenizer.ignore(len);
    }
    findSampleOffset(track, chapterOffset) {
        let totalDuration = 0;
        track.timeToSampleTable.forEach(e => {
            totalDuration += e.count * e.duration;
        });
        debug(`Total duration=${totalDuration}`);
        let chunkIndex = 0;
        while (chunkIndex < track.chunkOffsetTable.length && track.chunkOffsetTable[chunkIndex] < chapterOffset) {
            ++chunkIndex;
        }
        return this.getChunkDuration(chunkIndex + 1, track);
    }
    getChunkDuration(chunkId, track) {
        let ttsi = 0;
        let ttsc = track.timeToSampleTable[ttsi].count;
        let ttsd = track.timeToSampleTable[ttsi].duration;
        let curChunkId = 1;
        let samplesPerChunk = this.getSamplesPerChunk(curChunkId, track.sampleToChunkTable);
        let totalDuration = 0;
        while (curChunkId < chunkId) {
            const nrOfSamples = Math.min(ttsc, samplesPerChunk);
            totalDuration += nrOfSamples * ttsd;
            ttsc -= nrOfSamples;
            samplesPerChunk -= nrOfSamples;
            if (samplesPerChunk === 0) {
                ++curChunkId;
                samplesPerChunk = this.getSamplesPerChunk(curChunkId, track.sampleToChunkTable);
            }
            else {
                ++ttsi;
                ttsc = track.timeToSampleTable[ttsi].count;
                ttsd = track.timeToSampleTable[ttsi].duration;
            }
        }
        return totalDuration;
    }
    getSamplesPerChunk(chunkId, stcTable) {
        for (let i = 0; i < stcTable.length - 1; ++i) {
            if (chunkId >= stcTable[i].firstChunk && chunkId < stcTable[i + 1].firstChunk) {
                return stcTable[i].samplesPerChunk;
            }
        }
        return stcTable[stcTable.length - 1].samplesPerChunk;
    }
}
//# sourceMappingURL=MP4Parser.js.map

/***/ })

}]);
//# sourceMappingURL=vendors-node_modules_music-metadata_lib_mp4_MP4Parser_js.4acef80b84352b64e6d9.js.map